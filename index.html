<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js 动态小方块</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        z-index: 1;
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="info">鼠标滚轮可旋转立方体</div>
    <canvas id="cube-canvas"></canvas>

    <!-- 引入 Three.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="//cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>

    <script>
      // 获取画布元素
      const canvas = document.getElementById("cube-canvas");

      // 创建渲染器
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true, // 允许透明背景
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding; // 输出编码
      renderer.toneMapping = THREE.ACESFilmicToneMapping; // 高质量色调映射
      renderer.toneMappingExposure = 1; // 调整曝光
      renderer.setClearColor(0x000000, 0); // 透明背景

      // 创建场景
      const scene = new THREE.Scene();
      scene.background = null; // 确保背景透明

      // 创建相机（侧视图）
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-5, 3, 5); // 从侧上方观察
      camera.lookAt(0, 0, 0);

      // 添加环境光用于柔和照明
      const ambientLight = new THREE.AmbientLight(0x404040); // 柔和的白光
      scene.add(ambientLight);

      // 添加方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      // 初始化旋转角度
      let rotationY = 0;

      // 监听鼠标滚轮事件，实现旋转
      window.addEventListener("wheel", (event) => {
        // event.deltaY 为滚轮的垂直滚动量
        // 根据滚动方向调整旋转角度
        rotationY += event.deltaY * 0.001; // 调整旋转速度
      });

      // 加载 HDR 环境贴图
      const rgbeLoader = new THREE.RGBELoader();
      rgbeLoader.setDataType(THREE.UnsignedByteType);
      rgbeLoader.load("/cube-texture.hdr", (hdrTexture) => {
        hdrTexture.mapping = THREE.EquirectangularReflectionMapping;

        // 使用 PMREMGenerator 预处理 HDR 环境贴图
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
        scene.environment = envMap;
        hdrTexture.dispose();
        pmremGenerator.dispose();

        // 加载其他纹理
        const textureLoader = new THREE.TextureLoader();

        const topTexture = textureLoader.load("/imgs/cube-top.jpg");
        topTexture.encoding = THREE.sRGBEncoding;
        topTexture.wrapS = topTexture.wrapT = THREE.RepeatWrapping;
        topTexture.repeat.set(1, 1);

        const leftTexture = textureLoader.load("/imgs/cube-left.jpg");
        leftTexture.encoding = THREE.sRGBEncoding;
        leftTexture.wrapS = leftTexture.wrapT = THREE.RepeatWrapping;
        leftTexture.repeat.set(1, 1);

        const rightTexture = textureLoader.load("/imgs/cube-right.jpg");
        rightTexture.encoding = THREE.sRGBEncoding;
        rightTexture.wrapS = rightTexture.wrapT = THREE.RepeatWrapping;
        rightTexture.repeat.set(1, 1);

        // 基础材质
        const baseMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0x222222,
          emissiveIntensity: 1,
          roughness: 0.1,
          metalness: 0.6,
          envMap: envMap,
          envMapIntensity: 1,
        });

        // 克隆材质用于不同面并分配纹理
        const materialTop = baseMaterial.clone();
        materialTop.map = topTexture;
        materialTop.emissiveMap = topTexture;

        const materialLeft = baseMaterial.clone();
        materialLeft.map = leftTexture;
        materialLeft.emissiveMap = leftTexture;

        const materialRight = baseMaterial.clone();
        materialRight.map = rightTexture;
        materialRight.emissiveMap = rightTexture;

        // 为立方体各面分配材质
        const materials = [
          materialLeft, // 右侧
          materialLeft, // 左侧
          materialTop, // 顶部
          materialTop, // 底部
          materialRight, // 前面
          materialRight, // 后面
        ];

        // 创建带圆角的立方体几何体和网格
        const roundedBoxGeometry = new THREE.RoundedBoxGeometry(
          1,
          1,
          1,
          16,
          0.1
        );
        const cube = new THREE.Mesh(roundedBoxGeometry, materials);
        scene.add(cube);

        // 动画循环
        const animate = () => {
          requestAnimationFrame(animate);

          // 更新立方体旋转
          cube.rotation.y = rotationY;

          // 动态旋转方向光以模拟动态反射
          directionalLight.position.x = 5 * Math.cos(Date.now() * 0.001);
          directionalLight.position.z = 5 * Math.sin(Date.now() * 0.001);
          directionalLight.position.y = 5;
          directionalLight.lookAt(0, 0, 0);

          // 渲染场景
          renderer.render(scene, camera);
        };

        animate();
      });

      // 处理窗口大小调整
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
